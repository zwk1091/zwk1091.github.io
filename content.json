{"posts":[{"title":"leetcode 673. 最长递增子序列的个数","text":"给定一个未排序的整数数组，找到最长递增子序列的个数。 示例 1: 输入: [1,3,5,4,7]输出: 2解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。示例 2: 输入: [2,2,2,2,2]输出: 5解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。注意: 给定的数组长度不超过 2000 并且结果一定是32位有符号整数。 123456789101112131415161718192021222324252627282930313233343536373839class Solution {public: int findNumberOfLIS(vector&lt;int&gt;&amp; nums) { if(nums.size()&lt;=0) { return 0; } vector&lt;int&gt; dp_nums(nums.size(),1); vector&lt;int&gt; dp_length(nums.size(),1); int max_length=1; dp_nums[0]=1; dp_length[0]=1; for (int i = 1; i &lt; nums.size(); i++) { for (int j = 0; j &lt; i; j++) { if(nums[j]&lt;nums[i]) { if(dp_length[j]+1==dp_length[i]) { dp_nums[i]=dp_nums[j]+dp_nums[i]; } else if(dp_length[j]+1&gt;dp_length[i]) { dp_nums[i]=dp_nums[j]; dp_length[i]=dp_length[j]+1; if(dp_length[i]&gt;max_length) { max_length=dp_length[i]; } } } } } // 将所有最长的子序列的个数累加 int count=0; for (int i = 0; i &lt; dp_nums.size(); i++) { if(dp_length[i]==max_length) { count+=dp_nums[i]; } } return count; }};","link":"/2020/03/20/leetcode673/"},{"title":"leetcode 673. 完全平方数","text":"给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1: 输入: n = 12输出: 3解释: 12 = 4 + 4 + 4.示例 2: 输入: n = 13输出: 2解释: 13 = 4 + 9. 法1： 动态规划，时间复杂度O(n*sqrt(n)), 空间复杂度O(n) 1234567891011121314151617181920212223class Solution {public: int numSquares(int n) { vector&lt;int&gt; dp(n+1, 0); vector&lt;int&gt; mults; int i = 1; while(i*i &lt;= n) { mults.push_back(i*i); i++; } for (int i = 1; i &lt;= n; i++) { int min_nums = i+1; for (int j = 0; j &lt; mults.size() &amp;&amp; i &gt;= mults[j]; j++) { min_nums = min(min_nums, dp[i - mults[j]] + 1 ); } dp[i] = min_nums; } return dp[n]; }}; 法2：数学方法, 时间复杂度：O(sqrt(n)), 空间复杂度O(1). 1234567891011121314151617181920212223242526class Solution { protected boolean isSquare(int n) { int sq = (int) Math.sqrt(n); return n == sq * sq; } public int numSquares(int n) { // four-square and three-square theorems. while (n % 4 == 0) n /= 4; if (n % 8 == 7) return 4; if (this.isSquare(n)) return 1; // enumeration to check if the number can be decomposed into sum of two squares. for (int i = 1; i * i &lt;= n; ++i) { if (this.isSquare(n - i * i)) return 2; } // bottom case of three-square theorem. return 3; }}","link":"/2020/04/24/leetcode279/"},{"title":"leetcode 518. 零钱兑换 II","text":"给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 示例 1: 输入: amount = 5, coins = [1, 2, 5]输出: 4解释: 有四种方式可以凑成总金额:5=55=2+2+15=2+1+1+15=1+1+1+1+1示例 2: 输入: amount = 3, coins = [2]输出: 0解释: 只用面额2的硬币不能凑成总金额3。示例 3: 输入: amount = 10, coins = [10]输出: 1 注意: 你可以假设： 0 &lt;= amount (总金额) &lt;= 50001 &lt;= coin (硬币面额) &lt;= 5000硬币种类不超过 500 种结果符合 32 位符号整数 tips : 动态规划，每次只考虑一种硬币，这样可以避免计算一些重复的方案，时间复杂度O(n^2) 1234567891011121314151617class Solution {public: int change(int amount, vector&lt;int&gt;&amp; coins) { vector&lt;int&gt; dp(amount+1, 0); dp[0] = 1; for(int i = 0; i &lt; coins.size(); i++) { for(int j = 1; j&lt;amount+1; j++) { if(j-coins[i] &gt;= 0) { dp[j] = dp[j] + dp[j-coins[i]] ; } } } return dp[amount]; }};","link":"/2020/04/28/leetcode518/"},{"title":"计算机网络常用名词解释&amp;概念题","text":"OSI七层参考模型应用层：应用层是用户与网络的界面，应用层需要采用不同的应用层协议来解决不同类型的应用要求。表示层：主要用于处理在两个通信系统中交换信息的方式，表示层还提供数据压缩，加密和解密。会话层：会话层负责管理主机间的会话进程，包括建立管理以及终止进程间的会话。传输层：负责主机中的两个进程间的通信，为端到端的连接提供可靠的传输服务，为端到端的连接提供流量控制、差错控制、服务质量、数据传输管理等服务。网络层：把网络层的协议数据单元从源端传到目的端，为分组交换机上的不同主机提供通信服务。对分组进行路由选择，并实现流量控制，拥塞控制，差错控制。数据链路层：通过物理链路提供可靠的数据传输，设计物理寻址，网络拓扑，网络访问，错误通知，帧的有序传送以及流量控制。物理层：通信链路与通信节点的连接需要一些电路接口，物理层规定了这些接口的一些参数，物理层还规定了通信链路上传输的信号的意义和电气特征。 TCP/IP四层模型（将OSI模型中的应用层、会话层、表示层划分为应用层一层，数据链路层和物理层划分为网络接口层）应用层：处理高级协议，表示，编码和会话控制问题。TCP/IP将所有的应用程序相关的问题组合到一个层中。传输层：处理可靠性，流量控制和错误纠正的服务质量问题。网络层：将分组发往任何网络，并为之独立地选择合适的网络。网络接口层：从主机或结点接受IP分组，并把它们发送到指定的物理网络上。他包括局域网和广域网的技术细节，以及OSI物理和数据链路层的所有细节。 TDM(Time Division Multplexing)时分复用按传输信号的时间进行分割，它使不同的信号在不同的时间内传送，将整个传输时间分为许多时间间隔（又称时隙），每个时间片被一路信号占用。时分复用的所有用户在不同是时间占用的带宽一样。 FDM(Frequency Division Multplexing)频分复用频带被平均分为几分，用户在分配到一定的频带后，在通信过程中始终占用这个频带，所有用户在同样的时间内，还在那用不同的带宽资源，互不影响。 CSMA(Carrier Sense Multiple Access) 载波侦听多路访问主要思想：先侦听一下信道，发现空闲后再发送数据有三种类型：1-坚持CSMA: 要发送数据时，先侦听信道，如果信道空闲就立即发送数据，如果信道忙则等待，同时继续侦听直到信道空闲非坚持CSMA: 与上面不同的是，如果信道忙则放弃侦听，等待一个随机的过程后再重复上述过程p-坚持CSMA:与上不同的是，如果信道忙则等待一个时隙在侦听，如果信道空闲，则以概率p发送数据，以概率1-p推迟到下一个时隙，如果在下一个时隙信道仍空闲，则继续概率p发送数据，以概率1-p推迟到下一个时隙。 CSMA/CD(Carrier Sense Multiple Access with Collision Detection)载波侦听多路访问/碰撞检测在发送前先检测一下是否有其他站点在发送数据，如果有，则暂时不要发送数据，等待信道空闲后再发送，碰撞检测就是变侦听变发送，以便判断自己在发送数据的时候其他站点是否也在发送数据。 PPP(Point-to-Point Protocol) 点对点协议为在点对点的连接的传输多协议数据包提供了一个标准的方法，PPP具有省份验证功能，提供成帧、链路控制、网络控制功能。 STP(Spanning Tree Protocol) 生成树协议改协议的原理是按照树的结构来构造网络拓扑，消除网络中的环路。生成树算法的过程：1. 选择根网桥；2. 选择根端口；3. 选择制定端口。 NAT(Networking Address Translation) 网络地址转换、一种把内部私有的网络地址翻译成合法的网络IP地址的技术，从而对外隐藏了内部管理的IP地址，它使得整个专用网只需要一个全球IP地址就可以与因特网连通，由于专用网本地IP地址是可重用的，所以NAT大大节省了IP地址的消耗。 CIDR(Classless Inter-Domain Routing 无类别域间路由选择)CIDR是在变长子网掩码的基础上提出的一种消除传统A、B、C类网络划分，并且可以在软件的支持下实现超网构造的一种IP地址的划分。 距离向量路由算法所有结点都定期将它们的整个路由选择表传送给与之直接相邻的结点 链路状态路由算法链路状态发生变化时将结点链路状态传播给所有其他结点，通过洪泛法向所有路由器发送信息，即路由器通过所有端口向所有相邻路由器发送信息，而每一个相邻路由器又将次此信息发送往其他所有相邻路由器 RIP(Routing Information Protocol) 路由信息协议是一种内部网关协议（IGP）,是一种动态路由选择协议，通过距离矢量算法，使用跳数来衡量到达目标地址的路由距离。特点：仅和相邻的路由器交换信息，即自己的路由表，按固定的时间间隔交换路由信息，如每隔30秒 OSPF（Open Shortest Path First）开放最短路径优先是一个内部网关协议（IGP）, 用于在单一自治系统内决策路由。与RIP相比，OSPF是链路状态协议，而RIP是距离矢量协议。各路由器之间频繁交换链路状态信息，因此所有路由器都能最终建立一个链路状态数据库，每个路由器根据全网的拓扑结构图，使用最短路径算法计算从自己到各个目的网路的最优路径，以此构造自己的路由表，链路状态发生变化时，每个路由器重新计算到各目的网路的最优路径，构造新的路由表。","link":"/2018/10/31/network/"},{"title":"博客写作指导","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment the theme i usedhttps://github.com/ppoffice/hexo-theme-icarus","link":"/2018/04/24/hexo-readme/"},{"title":"Golang 常见面试题","text":"GMP调度模型 G：Go协程 M：⼯作线程，数量对应于真实的CPU数 P：处理器，包含运⾏Go代码 的必要资源，⽤来调度G和M之间的关联关系 M必须拥有P才能执⾏G中的代码，P含有⼀个包含多个G的队列，P可以调度G交由 M执⾏。 https://juejin.cn/post/6844904130398404616 GC三⾊标记法：https://juejin.cn/post/7111515970669117447 初始时所有对象都是⽩⾊ 从gc root对象出发，扫描所有可达对象标记为灰⾊，放⼊待处理队列 从队列取出⼀个灰⾊对象标记为⿊⾊，将其引⽤标记为灰⾊，放⼊队列 重复直⾄灰⾊对象队列为空 剩下所有⽩⾊对象都是垃圾对象 强三⾊不变性：⿊⾊对象不会指向⽩⾊对象，只会指向灰⾊对象或者⿊⾊对象 弱三 ⾊不变性：⿊⾊对象指向的⽩⾊对象必须包含⼀条从灰⾊对象经由多个⽩⾊对象的 可达路径 插⼊写屏障：当⼀个对象引⽤另外⼀个对象时，将另外⼀个对象标记为灰⾊，以此 满⾜强三⾊不变性，不会存在⿊⾊对象引⽤⽩⾊对象 删除写屏障：在灰⾊对象删除 对⽩⾊对象的引⽤时，将⽩⾊对象置为灰⾊，其实就是快照保存旧的引⽤关系，满 ⾜弱三⾊不变性 Context用法 3个基础能力，取消、超时、附加值 Go垃圾回收 https://blog.csdn.net/Dong_chongwu/article/details/128710443 Go的逃逸分析 逃逸分析：在函数内部定义了一个局部变量，然后返回这个局部变量的地址（指针）。由于这些局部变量是在栈上分配的（静态内存分配），一旦函数执行完毕，变量占据的内存被销毁，任何对这个返回值的动作（如解引用），都将扰乱程序的运行，甚至导致程序直接崩溃 https://blog.csdn.net/weixin_39299288/article/details/119772086 channel go的profile工具 pprof 写代码的时候如何减少小对象分配 go实现不重启热部署 go并发机制 go内存操作也要处理IO，是如何处理的 gomap并发安全问题，如何解决 golang:切片和数组、map、gc、gpm调度模型 syncpool的实现原理 channel和锁对比一下 channel的应用场景 向为nil的channel发送数据会怎么样 map取一个key，然后修改这个值，原map数据的值会不会变化 gostruct能不能比较 context包的用途 slice，len，cap，共享，扩容 map如何顺序读取 go结构体和结构体指针的区别 go深拷贝，什么时候需要深拷贝 如何拿到多个goroutine的返回值，如何区别他们 go如何避免panic gochannel实现排序 读过什么go源码没有 连接池 go什么场景使用接口 channel和共享内存有什么优劣势 golang用到哪些框架 你觉得java和golang有什么优势劣势 defer用的多吗？有哪些应用 异常捕获是如何做的 如何实现一个线程安全的map 创建一个数组底层扩容 make一个slice参数怎么写？ 为什么不要大量使用goroutine go里面goroutine创建数量有限制吗？ 每个协程至少需要消耗 2KB 的空间，那么假设计算机的内存是 2GB，那么至多允许 2GB/2KB = 1M 个协程同时存在。 协程数能看多少取决于打开协程处理方法所占的CPU和内存，如果只是空的操作，那么理论上内存会首先成为瓶颈，此时2G的内存跑满之后程序会出现错误。如果是CPU密集型的话则可能两三个协程就会让程序出现异常。 可以通过channel控制goroutine数量 线程和协程有什么区别 golang支持哪些并发机制 go利用channel通信的方式 有缓冲和无缓冲channel的区别 channel实现原理 被close的channel会有什么问题 分布式锁知道哪些？用channel如何实现？ 集群用channel如何实现分布式锁 并行goroutine如何实现 go用共享内存的方式实现并发如何保证安全？ go的锁是可重入的吗？ 获取不到锁会一直等待吗？ 那如何实现一个timeout的锁？ go切片是如何实现的 go怎么实现封装继承多态 为什么go的变量申请类型是为了什么？","link":"/2023/07/08/golang/"},{"title":"K8s 常见面试题","text":"介绍下k8s的基础组件 k8s组件的职责 介绍下和k8s有关的项目 docker是基于什么来实现的 docker分层打包了解吗 docker怎么看日志 容器的cpu和内存占比 docker端口映射怎么看？ 定制化开发了哪些功能？ 监听pod状态变化是怎么实现的 对k8s使用了解到什么程度，组件这些 如果有一个节点不可用了，如何把pod驱逐到其他节点 kubectlapply和create有什么区别 如何更新一个k8s服务 pod里面可以有多个容器吗 pod内容器是相互隔离的吗 你们怎么去监控一个服务是否故障 容器日志是如何采集的，流程是怎么走的 dockerfile经常写，有什么常用命令 cmd和entrypoint有什么区别 介绍下在线上课的项目 docker和虚拟机有什么区别 serviceMash用来解决什么问题的？ devops相关技术有哪些 k8s如何找到一个节点上的所有pod 如何通过goclient写代码获取","link":"/2023/07/08/k8s/"}],"tags":[{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"categories":[{"name":"算法题","slug":"算法题","link":"/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Golang","slug":"Golang","link":"/categories/Golang/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/categories/Kubernetes/"}],"pages":[{"title":"about","text":"Steven Zhu 2 years old Software Engineer. My ex-blogs: https://blog.csdn.net/hello_my_coder","link":"/about/index.html"},{"title":"","text":"给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1: 输入: n = 12输出: 3解释: 12 = 4 + 4 + 4.示例 2: 输入: n = 13输出: 2解释: 13 = 4 + 9. 法1： 动态规划，时间复杂度O(n*sqrt(n)), 空间复杂度O(n) 1234567891011121314151617181920212223class Solution {public: int numSquares(int n) { vector&lt;int&gt; dp(n+1, 0); vector&lt;int&gt; mults; int i = 1; while(i*i &lt;= n) { mults.push_back(i*i); i++; } for (int i = 1; i &lt;= n; i++) { int min_nums = i+1; for (int j = 0; j &lt; mults.size() &amp;&amp; i &gt;= mults[j]; j++) { min_nums = min(min_nums, dp[i - mults[j]] + 1 ); } dp[i] = min_nums; } return dp[n]; }}; 法2：数学方法, 时间复杂度：O(sqrt(n)), 空间复杂度O(1). 1234567891011121314151617181920212223242526class Solution { protected boolean isSquare(int n) { int sq = (int) Math.sqrt(n); return n == sq * sq; } public int numSquares(int n) { // four-square and three-square theorems. while (n % 4 == 0) n /= 4; if (n % 8 == 7) return 4; if (this.isSquare(n)) return 1; // enumeration to check if the number can be decomposed into sum of two squares. for (int i = 1; i * i &lt;= n; ++i) { if (this.isSquare(n - i * i)) return 2; } // bottom case of three-square theorem. return 3; }}","link":"/algo/leetcode279.html"}]}